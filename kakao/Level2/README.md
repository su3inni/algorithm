## Remind Point 
### 1. 제한사항 확인하기 
+ 제한사항 범위를 확인하고 어떤 방식으로 문제를 해결할 것인지 파악하기
  > 1억번 == 1초 라고 생각하고 N크기가 10000보다 큰 경우 완전탐색은 어렵다
+ 너무 값이 크면 완전탐색이 어렵기 때문에 **규칙성을 찾아보자**

### 2. DFS로 조합하기 
+ [가능한 모든 조합을 DFS](https://github.com/su3inni/algorithm/blob/main/kakao/Level2/이모티콘할인행사.py)로 구하기
  > 단,범위가 작아서 완전탐색이 가능할 때

### 3. 시간을 다루는 문제라면
+ **59분 다음이 00분인 경우의 처리**가 잘 되었는지 확인하기
  > 11:59 에서 00:00 넘어가는 시점같은

### 4. 소수판별하는 경우 시간복잡도 줄이기 
+ for문 범위에서 (2,i//2) 는 연산 시간을 반으로 줄일 수 있고
+ 루트를 활용한다면 엄청난 연산 단축을 할 수 있다.
  > k_primenum.py ( K진법으로 소수 개수 구하기) 코드 확인

### 5. K 진법 변환 
+ while 문으로 몫과 나머지 활용
  > k_primenum.py ( K진법으로 소수 개수 구하기) 코드 확인

### 6. 시간복잡도 고려하기 
+ list 의 pop(0)보다 deque의 popleft()를 사용하는 것이 시간복잡도에 유리
+ 반복문 내에서 sum() 을 하는 경우 시간 복잡도가 늘어날 수 있으니 값을 -= += 하는 것으로 대체할 수 있는지 확인하기
